<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>プロセカ風音ゲー</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background-color: black; color: white;
    font-family: 'Arial', sans-serif;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  #titleScreen, #gameScreen, #resultScreen {
    position: absolute; top:0; left:0; width:100vw; height:100vh;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    background-color: black;
  }
  #gameScreen, #resultScreen { display: none; }

  #songList {
    display: flex; gap: 12px; margin-bottom: 10px;
  }
  .songItem {
    cursor: pointer; padding: 8px 16px; border: 2px solid white; border-radius: 6px;
    user-select: none;
  }
  .songItem:hover {
    background: cyan; color: black;
  }

  #difficultySelector, #laneSelector, #startGameButton {
    margin: 6px;
    padding: 8px 16px;
    font-size: 16px;
  }

  canvas {
    display: block;
    background-color: #000;
    touch-action: none;
  }

  #retryButton, #backButton {
    margin: 10px;
    padding: 8px 20px;
    font-size: 18px;
    cursor: pointer;
    border-radius: 8px;
    border: none;
    background: cyan;
    color: black;
  }

  #scoreCombo {
    position: absolute;
    top: 10px; left: 10px;
    font-size: 22px;
    font-weight: bold;
    color: white;
    user-select: none;
  }
</style>
</head>
<body>

<!-- タイトル画面 -->
<div id="titleScreen">
  <h1 style="font-size: 48px; color: cyan; text-shadow: 0 0 8px cyan;">プロセカ風音ゲー</h1>

  <div id="songList"></div>

  <select id="difficultySelector">
    <option value="easy">Easy</option>
    <option value="normal" selected>Normal</option>
    <option value="hard">Hard</option>
  </select>

  <select id="laneSelector">
    <option value="4">4レーン</option>
    <option value="6" selected>6レーン</option>
    <option value="8">8レーン</option>
  </select>

  <button id="startGameButton">スタート</button>
</div>

<!-- ゲーム画面 -->
<div id="gameScreen">
  <canvas id="gameCanvas"></canvas>
  <div id="scoreCombo"></div>
  <button id="retryButton" style="position: absolute; bottom: 20px; right: 20px; display:none;">リトライ</button>
  <button id="backButton" style="position: absolute; bottom: 20px; left: 20px;">タイトルへ</button>
</div>

<!-- リザルト画面 -->
<div id="resultScreen" style="flex-direction: column;">
  <h2 id="finalScore" style="font-size: 36px; margin-bottom: 16px;"></h2>
  <h2 id="finalRank" style="font-size: 36px; margin-bottom: 40px;"></h2>
  <button id="retryButtonResult">リトライ</button>
  <button id="backButtonResult" style="margin-top: 10px;">タイトルへ</button>
</div>

<!-- 音声ファイル（ユーザーで差し替えてください） -->
<audio id="bgm" src="" preload="auto"></audio>
<audio id="tapSound" src="tap.mp3" preload="auto"></audio>
<audio id="perfectSound" src="perfect.mp3" preload="auto"></audio>
<audio id="greatSound" src="great.mp3" preload="auto"></audio>
<audio id="goodSound" src="good.mp3" preload="auto"></audio>
<audio id="missSound" src="miss.mp3" preload="auto"></audio>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // 要素取得
  const titleScreen = document.getElementById('titleScreen');
  const gameScreen = document.getElementById('gameScreen');
  const resultScreen = document.getElementById('resultScreen');

  const songList = document.getElementById('songList');
  const difficultySelector = document.getElementById('difficultySelector');
  const laneSelector = document.getElementById('laneSelector');
  const startGameButton = document.getElementById('startGameButton');

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const bgm = document.getElementById('bgm');
  const tapSound = document.getElementById('tapSound');
  const perfectSound = document.getElementById('perfectSound');
  const greatSound = document.getElementById('greatSound');
  const goodSound = document.getElementById('goodSound');
  const missSound = document.getElementById('missSound');

  const retryButton = document.getElementById('retryButton');
  const backButton = document.getElementById('backButton');
  const retryButtonResult = document.getElementById('retryButtonResult');
  const backButtonResult = document.getElementById('backButtonResult');

  const scoreCombo = document.getElementById('scoreCombo');

  // 曲リスト
  const songs = [
    { title: 'メデ', file: 'mede.mp3' },
    { title: '曲2', file: 'song2.mp3' },
    { title: '曲3', file: 'song3.mp3' }
  ];

  // 初期値
  let selectedSong = songs[0];
  let lanes = [];
  const laneKeys = ['D', 'F', 'G', 'H', 'J', 'K', 'L', ';'];
  let notes = [];
  let effects = [];
  let judgeEffects = [];
  let score = 0;
  let combo = 0;
  let gameRunning = false;
  let spawnInterval;
  let animationId;

  // 難易度設定
  const difficulties = {
    easy: { noteSpeed: 3, spawnRate: 900 },
    normal: { noteSpeed: 5, spawnRate: 600 },
    hard: { noteSpeed: 7, spawnRate: 400 }
  };

  let noteSpeed = difficulties.normal.noteSpeed;
  let noteSpawnRate = difficulties.normal.spawnRate;
  let laneCount = 6;

  // 画面リサイズ対応
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeLanes();
  }
  window.addEventListener('resize', resizeCanvas);

  // レーン初期化
  function initializeLanes() {
    lanes = [];
    let laneWidth = 60;
    let totalWidth = laneWidth * laneCount;
    let startX = (canvas.width - totalWidth) / 2 + laneWidth / 2;

    for (let i = 0; i < laneCount; i++) {
      lanes.push(startX + i * laneWidth);
    }
  }

  // 曲リスト描画
  songs.forEach(song => {
    const songButton = document.createElement('div');
    songButton.className = 'songItem';
    songButton.innerText = song.title;
    songButton.onclick = () => {
      selectedSong = song;
      Array.from(songList.children).forEach(child => child.style.color = 'white');
      songButton.style.color = 'yellow';
    };
    songList.appendChild(songButton);
  });

  // ゲーム開始処理
  function startGame() {
    score = 0;
    combo = 0;
    notes = [];
    effects = [];
    judgeEffects = [];

    gameRunning = true;
    noteSpeed = difficulties[difficultySelector.value].noteSpeed;
    noteSpawnRate = difficulties[difficultySelector.value].spawnRate;
    laneCount = parseInt(laneSelector.value);

    resizeCanvas();

    titleScreen.style.display = 'none';
    resultScreen.style.display = 'none';
    gameScreen.style.display = 'block';
    retryButton.style.display = 'none';

    bgm.src = selectedSong.file;

    // 音声再生はユーザーアクションが必要な場合があるので例外処理
    bgm.play().catch(() => {
      document.body.addEventListener('touchstart', function playOnTouch() {
        bgm.play();
        document.body.removeEventListener('touchstart', playOnTouch);
      });
    });

    bgm.onended = () => {
      endGame();
    };

    spawnInterval = setInterval(() => {
      if (!gameRunning) return;
      const laneIndex = Math.floor(Math.random() * laneCount);
      const lane = lanes[laneIndex];
      notes.push({ x: lane - 25, y: 0, laneIndex: laneIndex });
    }, noteSpawnRate);

    if (animationId) cancelAnimationFrame(animationId);
    draw();
  }

  // 描画ループ
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 判定ライン
    ctx.fillStyle = 'cyan';
    ctx.fillRect(0, canvas.height - 100, canvas.width, 5);

    // レーン線
    ctx.strokeStyle = 'white';
    lanes.forEach(lane => {
      ctx.beginPath();
      ctx.moveTo(lane, 0);
      ctx.lineTo(lane, canvas.height);
      ctx.stroke();
    });

    // ノーツ描画
    ctx.fillStyle = 'white';
    notes.forEach(note => {
      ctx.fillRect(note.x, note.y, 50, 50);
      note.y += noteSpeed;
    });

    // キー表示
    ctx.fillStyle = 'yellow';
    ctx.font = '24px Arial';
    lanes.forEach((lane, index) => {
      if (index < laneCount) {
        ctx.fillText(laneKeys[index], lane - 5, canvas.height - 10);
      }
    });

    // 判定エフェクト
    judgeEffects.forEach((effect, index) => {
      ctx.fillStyle = effect.color;
      ctx.font = '30px Arial';
      ctx.fillText(effect.text, effect.x, effect.y);
      effect.timer--;
      if (effect.timer <= 0) judgeEffects.splice(index, 1);
    });

    // ノーツエフェクト（円）
    effects.forEach((effect, index) => {
      ctx.strokeStyle = 'cyan';
      ctx.beginPath();
      ctx.arc(effect.x + 25, effect.y + 25, 30 - effect.timer, 0, 2 * Math.PI);
      ctx.stroke();
      effect.timer--;
      if (effect.timer <= 0) effects.splice(index, 1);
    });

    // スコア＆コンボ表示
    scoreCombo.innerText = `Score: ${score}  Combo: ${combo}`;

    // 画面外ノーツ削除
    notes = notes.filter(note => note.y <= canvas.height + 50);

    if (gameRunning) {
      animationId = requestAnimationFrame(draw);
    }
  }

  // ゲーム終了処理
  function endGame() {
    gameRunning = false;
    clearInterval(spawnInterval);
    if (animationId) cancelAnimationFrame(animationId);

    gameScreen.style.display = 'none';
    resultScreen.style.display = 'flex';

    document.getElementById('finalScore').innerText = `スコア: ${score}`;
    document.getElementById('finalRank').innerText = `ランク: ${getRank(score)}`;

    bgm.pause();
    bgm.currentTime = 0;
  }

  // スコアによるランク判定
  function getRank(score) {
    if (score >= 30000) return 'SS';
    else if (score >= 20000) return 'S';
    else if (score >= 15000) return 'A';
    else if (score >= 10000) return 'B';
    else return 'C';
  }

  // 判定取得
  function getJudge(noteY) {
    let hitLine = canvas.height - 100;
    let diff = Math.abs(noteY - hitLine);

    if (diff <= 22.5) return { text: 'Perfect', color: 'gold', sound: perfectSound };
    else if (diff <= 50) return { text: 'Great', color: 'blue', sound: greatSound };
    else if (diff <= 80) return { text: 'Good', color: 'green', sound: goodSound };
    else return { text: 'Miss', color: 'red', sound: missSound };
  }

  // ヒット処理
  function handleHit(note, index) {
    let judge = getJudge(note.y);
    notes.splice(index, 1);

    if (judge.text !== 'Miss') {
      combo++;
      switch (judge.text) {
        case 'Perfect': score += 1000; break;
        case 'Great': score += 700; break;
        case 'Good': score += 300; break;
      }
    } else {
      combo = 0;
    }

    judgeEffects.push({
      text: judge.text,
      color: judge.color,
      x: note.x,
      y: note.y,
      timer: 30
    });

    judge.sound.play();
  }

  // キー押下判定
  document.addEventListener('keydown', e => {
    if (!gameRunning) return;
    let key = e.key.toUpperCase();
    let laneIndex = laneKeys.indexOf(key);
    if (laneIndex === -1 || laneIndex >= laneCount) return;

    // 最も近いノーツを判定（hitLineに近い順）
    let candidateIndex = -1;
    let minDiff = Infinity;
    for (let i = 0; i < notes.length; i++) {
      if (notes[i].laneIndex === laneIndex) {
        let diff = Math.abs(notes[i].y - (canvas.height - 100));
        if (diff < minDiff) {
          minDiff = diff;
          candidateIndex = i;
        }
      }
    }
    if (candidateIndex !== -1) {
      let judge = getJudge(notes[candidateIndex].y);
      if (judge.text !== 'Miss') {
        handleHit(notes[candidateIndex], candidateIndex);
      }
    }
  });

  // タッチ対応（スマホ用） - タップで判定ラインに最も近いノーツを叩く
  canvas.addEventListener('touchstart', e => {
    if (!gameRunning) return;
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const touchX = e.touches[0].clientX - rect.left;

    // タッチ位置に近いレーンを判定
    let closestLaneIndex = 0;
    let minDist = Infinity;
    lanes.forEach((laneX, i) => {
      if (i >= laneCount) return;
      let dist = Math.abs(touchX - laneX);
      if (dist < minDist) {
        minDist = dist;
        closestLaneIndex = i;
      }
    });

    // そのレーンでhit判定可能なノーツを探す
    let candidateIndex = -1;
    let minDiff = Infinity;
    for (let i = 0; i < notes.length; i++) {
      if (notes[i].laneIndex === closestLaneIndex) {
        let diff = Math.abs(notes[i].y - (canvas.height - 100));
        if (diff < minDiff) {
          minDiff = diff;
          candidateIndex = i;
        }
      }
    }
    if (candidateIndex !== -1) {
      let judge = getJudge(notes[candidateIndex].y);
      if (judge.text !== 'Miss') {
        handleHit(notes[candidateIndex], candidateIndex);
      }
    }
  }, { passive: false });

  // リトライボタン処理（ゲーム画面）
  retryButton.addEventListener('click', () => {
    startGame();
  });

  // タイトルへ戻る（ゲーム画面）
  backButton.addEventListener('click', () => {
    gameRunning = false;
    clearInterval(spawnInterval);
    if (animationId) cancelAnimationFrame(animationId);

    gameScreen.style.display = 'none';
    resultScreen.style.display = 'none';
    titleScreen.style.display = 'flex';

    bgm.pause();
    bgm.currentTime = 0;
  });

  // リトライボタン（リザルト画面）
  retryButtonResult.addEventListener('click', () => {
    startGame();
  });

  // タイトルへ戻る（リザルト画面）
  backButtonResult.addEventListener('click', () => {
    resultScreen.style.display = 'none';
    titleScreen.style.display = 'flex';
  });

  // 初期選択色
  songList.children[0].style.color = 'yellow';

});
</script>

</body>
</html>
